#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the root directory (parent of bin/)
ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
DAILY_DIR="$ROOT_DIR/daily"
PROJECTS_DIR="$ROOT_DIR/projects"
REVIEWS_DIR="$ROOT_DIR/reviews"
RECURRING_TASKS_FILE="$ROOT_DIR/recurring-tasks.md"
SHARED_DIR="$ROOT_DIR/shared"

# Helper functions
log_info() {
    echo -e "${BLUE}â„¹${NC} $1"
}

log_success() {
    echo -e "${GREEN}âœ“${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}âš ${NC} $1"
}

log_error() {
    echo -e "${RED}âœ—${NC} $1"
}

# Get team member display name from team.md
get_display_name() {
    local project_dir="$1"
    local username="$2"
    local team_file="$project_dir/team.md"

    if [ ! -f "$team_file" ]; then
        echo "$username"
        return
    fi

    # Look for pattern: ### Name (@username)
    local display_name=$(grep "^### .* (@$username)" "$team_file" | sed 's/^### \(.*\) (@.*/\1/')

    if [ -z "$display_name" ]; then
        echo "$username"
    else
        echo "$display_name"
    fi
}

# Get project name from team.md
get_project_name() {
    local project_dir="$1"
    local team_file="$project_dir/team.md"

    if [ ! -f "$team_file" ]; then
        basename "$project_dir"
        return
    fi

    # Look for: **Project Name:** value
    local project_name=$(grep "^\*\*Project Name:\*\*" "$team_file" | sed 's/^\*\*Project Name:\*\* //')

    if [ -z "$project_name" ]; then
        basename "$project_dir"
    else
        echo "$project_name"
    fi
}

# Get date in various formats
get_date() {
    date +%Y-%m-%d
}

get_yesterday() {
    date -d "yesterday" +%Y-%m-%d 2>/dev/null || date -v-1d +%Y-%m-%d 2>/dev/null
}

get_last_working_day() {
    local day_of_week=$(date +%u)
    if [ "$day_of_week" = "1" ]; then
        # Monday - get Friday
        date -d "3 days ago" +%Y-%m-%d 2>/dev/null || date -v-3d +%Y-%m-%d 2>/dev/null
    else
        get_yesterday
    fi
}

get_day_name() {
    date -d "$1" +%A 2>/dev/null || date -j -f "%Y-%m-%d" "$1" +%A 2>/dev/null
}

get_readable_date() {
    date -d "$1" "+%A, %B %d, %Y" 2>/dev/null || date -j -f "%Y-%m-%d" "$1" "+%A, %B %d, %Y" 2>/dev/null
}

get_week_number() {
    date +%Y-W%V
}

get_month() {
    date +%Y-%m
}

get_day_of_week() {
    date +%A
}

get_day_of_month() {
    date +%d
}

# Get recurring tasks for a specific day
get_recurring_tasks() {
    local day_name=$(get_day_of_week)
    local day_num=$(get_day_of_month)
    local tasks=""

    if [ ! -f "$RECURRING_TASKS_FILE" ]; then
        return
    fi

    local in_section=""
    local capturing=false

    while IFS= read -r line; do
        # Check for section headers
        if [[ "$line" =~ ^##[[:space:]]+Daily\ Tasks ]]; then
            in_section="daily"
            capturing=true
            continue
        elif [[ "$line" =~ ^##[[:space:]]+${day_name}\ Tasks ]]; then
            in_section="$day_name"
            capturing=true
            continue
        elif [[ "$line" =~ ^##[[:space:]]+(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)\ Tasks ]] && [[ "${BASH_REMATCH[1]}" != "$day_name" ]]; then
            capturing=false
            continue
        elif [[ "$line" =~ ^##[[:space:]]+Weekend\ Tasks ]] && [[ "$day_name" == "Saturday" || "$day_name" == "Sunday" ]]; then
            in_section="weekend"
            capturing=true
            continue
        elif [[ "$line" =~ ^## ]]; then
            # Any other section header stops capturing
            capturing=false
            continue
        fi

        # Capture task lines if we're in an active section
        if [ "$capturing" = true ]; then
            # Skip empty lines and comments
            if [[ "$line" =~ ^[[:space:]]*$ ]] || [[ "$line" =~ ^\<!-- ]]; then
                continue
            fi
            # Capture checkbox tasks
            if [[ "$line" =~ ^-[[:space:]]+\[\ \] ]]; then
                tasks="${tasks}${line}"$'\n'
            fi
        fi
    done < "$RECURRING_TASKS_FILE"

    echo "$tasks"
}

# Command: new-day
cmd_new_day() {
    local today=$(get_date)
    local today_file="$DAILY_DIR/$today.md"

    if [ -f "$today_file" ]; then
        log_warning "Today's file already exists: $today_file"
        return
    fi

    local readable_date=$(get_readable_date "$today")
    local recurring_tasks=$(get_recurring_tasks)

    # Create the daily file with recurring tasks
    cat > "$today_file" << EOF
# Daily Tasks - $readable_date

## Today's Focus
-
-

## Tasks

### Recurring
$recurring_tasks
### Other
- [ ]

## Notes
-
EOF

    log_success "Created today's file: $today_file"

    # Count and display recurring tasks
    local task_count=$(echo "$recurring_tasks" | grep -c "^\- \[" || echo "0")
    if [ "$task_count" -gt 0 ]; then
        log_info "Added $task_count recurring task(s)"
    fi
}

# Command: add-task
cmd_add_task() {
    local task="$1"
    if [ -z "$task" ]; then
        log_error "Please provide a task description"
        echo "Usage: wip add-task \"Task description\""
        exit 1
    fi

    local today=$(get_date)
    local today_file="$DAILY_DIR/$today.md"

    if [ ! -f "$today_file" ]; then
        log_error "Today's file doesn't exist. Run 'wip new-day' first."
        exit 1
    fi

    # Add task under the ## Tasks section
    sed -i.bak "/## Tasks/a\\
- [ ] $task
" "$today_file" 2>/dev/null || sed -i '' "/## Tasks/a\\
- [ ] $task
" "$today_file" 2>/dev/null

    rm -f "$today_file.bak"

    log_success "Added task: $task"
}

# Command: review-yesterday
cmd_review_yesterday() {
    local last_day=$(get_last_working_day)
    local last_file="$DAILY_DIR/$last_day.md"

    if [ ! -f "$last_file" ]; then
        log_warning "No file found for $last_day"
        return
    fi

    log_info "Reviewing $(get_readable_date "$last_day")"
    echo ""
    cat "$last_file"
}

# Command: review-projects
cmd_review_projects() {
    local today=$(get_date)
    local projects_file="$PROJECTS_DIR/index.md"

    if [ ! -f "$projects_file" ]; then
        log_error "Projects index not found"
        exit 1
    fi

    log_info "Checking projects due for review..."
    echo ""

    # Parse and display projects due for review
    local found_any=false
    while IFS= read -r line; do
        if [[ "$line" =~ ^##[[:space:]]+(.+)$ ]]; then
            current_project="${BASH_REMATCH[1]}"
            current_status=""
            current_cadence=""
            current_last_reviewed=""
        elif [[ "$line" =~ ^-[[:space:]]+\*\*Review\ Cadence:\*\*[[:space:]]+(.+)$ ]]; then
            current_cadence="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^-[[:space:]]+\*\*Last\ Reviewed:\*\*[[:space:]]+(.+)$ ]]; then
            current_last_reviewed="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^-[[:space:]]+\*\*Status:\*\*[[:space:]]+(.+)$ ]]; then
            current_status="${BASH_REMATCH[1]}"

            # Check if project is due for review
            if [ -n "$current_cadence" ] && [ -n "$current_last_reviewed" ]; then
                local days_diff=$(( ( $(date -d "$today" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$today" +%s) - $(date -d "$current_last_reviewed" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$current_last_reviewed" +%s) ) / 86400 ))

                local due=false
                case "$current_cadence" in
                    daily)
                        [ $days_diff -ge 1 ] && due=true
                        ;;
                    weekly)
                        [ $days_diff -ge 7 ] && due=true
                        ;;
                    monthly)
                        [ $days_diff -ge 30 ] && due=true
                        ;;
                esac

                if [ "$due" = true ]; then
                    echo -e "${YELLOW}â—‹${NC} $current_project (Last reviewed: $current_last_reviewed, Cadence: $current_cadence)"
                    found_any=true
                fi
            fi
        fi
    done < "$projects_file"

    if [ "$found_any" = false ]; then
        log_success "All projects are up to date!"
    fi
}

# Command: weekly-summary
cmd_weekly_summary() {
    local week=$(get_week_number)
    local summary_file="$REVIEWS_DIR/weekly/$week.md"

    if [ -f "$summary_file" ]; then
        log_warning "Weekly summary already exists: $summary_file"
        return
    fi

    mkdir -p "$REVIEWS_DIR/weekly"

    cat > "$summary_file" << EOF
# Weekly Summary - $week

## Accomplishments
-

## Challenges
-

## Key Learnings
-

## Next Week's Focus
-

## Projects Updated
-

## Notes
-
EOF

    log_success "Created weekly summary: $summary_file"
}

# Command: monthly-summary
cmd_monthly_summary() {
    local month=$(get_month)
    local summary_file="$REVIEWS_DIR/monthly/$month.md"

    if [ -f "$summary_file" ]; then
        log_warning "Monthly summary already exists: $summary_file"
        return
    fi

    mkdir -p "$REVIEWS_DIR/monthly"

    local month_name=$(date +%B)
    local year=$(date +%Y)

    cat > "$summary_file" << EOF
# Monthly Summary - $month_name $year

## Major Accomplishments
-

## Projects Completed
-

## Projects In Progress
-

## Challenges & Blockers
-

## Key Learnings
-

## Metrics
- Days worked:
- Projects active:
- Key deliverables:

## Next Month's Goals
-

## Notes
-
EOF

    log_success "Created monthly summary: $summary_file"
}

# Command: list-days
cmd_list_days() {
    local days="${1:-7}"
    log_info "Last $days daily files:"
    echo ""

    ls -1t "$DAILY_DIR"/*.md 2>/dev/null | head -n "$days" | while read file; do
        local basename=$(basename "$file" .md)
        local day_name=$(get_day_name "$basename")
        echo "  $basename ($day_name)"
    done
}

# Command: open-project
cmd_open_project() {
    local project="$1"

    if [ -z "$project" ]; then
        log_error "Please provide a project name"
        echo "Usage: wip open-project <project-name>"
        exit 1
    fi

    local project_dir="$PROJECTS_DIR/$project"
    local notes_file="$project_dir/notes.md"

    if [ ! -d "$project_dir" ]; then
        log_warning "Project directory doesn't exist: $project_dir"
        echo "Creating it now..."
        mkdir -p "$project_dir"
    fi

    if [ ! -f "$notes_file" ]; then
        cat > "$notes_file" << EOF
# $project Notes

## Overview


## Meeting Notes


## Research & Links


## Technical Details


## Progress Log

### Week of $(get_date)
-
EOF
        log_success "Created notes file: $notes_file"
    fi
}

# Command: log-project (collaborative shared projects - simple format)
cmd_log_project() {
    local project="$1"

    if [ -z "$project" ]; then
        log_error "Please provide a project name"
        echo "Usage: wip log-project <project-name>"
        exit 1
    fi

    local project_dir="$SHARED_DIR/$project"

    if [ ! -d "$project_dir" ]; then
        log_error "Shared project not found: $project_dir"
        exit 1
    fi

    # Get user identity
    local me_file="$project_dir/.me"
    if [ ! -f "$me_file" ]; then
        log_error "Identity file not found. Please create $me_file with your name"
        exit 1
    fi

    local username=$(cat "$me_file")
    local today=$(get_date)
    local daily_dir="$project_dir/daily/$username"
    local daily_file="$daily_dir/$today.md"

    # Create daily directory if it doesn't exist
    mkdir -p "$daily_dir"

    # Check if file exists
    if [ ! -f "$daily_file" ]; then
        # Create new daily log
        local display_name=$(get_display_name "$project_dir" "$username")
        cat > "$daily_file" << EOF
# $today - $display_name

## Completed

## In Progress

## Blockers

## Notes

EOF
        log_success "Created new daily log: $daily_file"
    fi

    # Auto-commit if there are changes
    cd "$project_dir"
    if ! git diff --quiet "$daily_file" 2>/dev/null; then
        log_info "Committing changes..."
        git add "$daily_file"
        git commit -m "$username: Daily update $today" -m "$(cat <<'EOF'
ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"

        # Push if remote is configured
        if git remote get-url origin &>/dev/null; then
            log_info "Pushing to remote..."
            git push origin main 2>&1 || log_warning "Push failed - you may need to pull first or set up remote"
        else
            log_warning "No remote configured - commit saved locally"
        fi

        log_success "Daily log updated and committed"
    else
        log_info "No changes to commit"
    fi
}

# Command: team-log (post structured work entry)
cmd_team_log() {
    local project="$1"
    local task_summary="$2"

    if [ -z "$project" ] || [ -z "$task_summary" ]; then
        log_error "Please provide project name and task summary"
        echo "Usage: wip team-log <project-name> <task-summary>"
        echo ""
        echo "Example: wip team-log myproject \"TTC-123: User authentication\""
        echo ""
        echo "You'll be prompted for:"
        echo "  - Remaining estimate (e.g., '2 days', '4 hours')"
        echo "  - Focus/Notes"
        echo "  - Challenges/Learnings (optional)"
        exit 1
    fi

    local project_dir="$SHARED_DIR/$project"

    if [ ! -d "$project_dir" ]; then
        log_error "Shared project not found: $project_dir"
        exit 1
    fi

    # Get user identity
    local me_file="$project_dir/.me"
    if [ ! -f "$me_file" ]; then
        log_error "Identity file not found. Please create $me_file with your name"
        exit 1
    fi

    local username=$(cat "$me_file")
    local display_name=$(get_display_name "$project_dir" "$username")
    local today=$(get_date)
    local daily_dir="$project_dir/daily/$username"
    local daily_file="$daily_dir/$today.md"

    # Create daily directory if it doesn't exist
    mkdir -p "$daily_dir"

    # Check if file exists, create header if not
    if [ ! -f "$daily_file" ]; then
        cat > "$daily_file" << EOF
# $today - $display_name

EOF
    fi

    # Prompt for details
    echo ""
    echo "Adding work entry for: $task_summary"
    echo ""

    read -p "Remaining Estimate (e.g., '2 days', '4 hours'): " estimate
    echo ""
    echo "Focus/Notes (press Enter when done, Ctrl+D to finish):"
    focus=$(cat)
    echo ""
    read -p "Challenges/Learnings (press Enter to skip): " challenges

    # Build the entry
    local entry="## [$project] - $task_summary\n"
    entry="${entry}- **Remaining Estimate:** $estimate\n"
    entry="${entry}- **Focus/Notes:** $focus\n"

    if [ -n "$challenges" ]; then
        entry="${entry}- **Challenges/Learnings:** $challenges\n"
    fi

    entry="${entry}\n"

    # Append to file
    echo -e "$entry" >> "$daily_file"

    log_success "Work entry added to $daily_file"

    # Auto-commit
    cd "$project_dir"
    log_info "Committing changes..."
    git add "$daily_file"
    git commit -m "$username: Work log - $task_summary" -m "$(cat <<'EOF'
ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"

    # Push if remote is configured
    if git remote get-url origin &>/dev/null; then
        log_info "Pushing to remote..."
        git push origin main 2>&1 || log_warning "Push failed - you may need to pull first or set up remote"
    else
        log_warning "No remote configured - commit saved locally"
    fi

    log_success "Team log updated and pushed"
}

# Command: add-request (create todo for team member)
cmd_add_request() {
    local project="$1"
    local target_member="$2"
    local task="$3"

    if [ -z "$project" ] || [ -z "$target_member" ] || [ -z "$task" ]; then
        log_error "Please provide project name, target member, and task"
        echo "Usage: wip add-request <project-name> <member> <task>"
        echo ""
        echo "Example: wip add-request myproject john \"Review PR #123\""
        exit 1
    fi

    local project_dir="$SHARED_DIR/$project"

    if [ ! -d "$project_dir" ]; then
        log_error "Shared project not found: $project_dir"
        exit 1
    fi

    # Get user identity
    local me_file="$project_dir/.me"
    if [ ! -f "$me_file" ]; then
        log_error "Identity file not found. Please create $me_file with your name"
        exit 1
    fi

    local username=$(cat "$me_file")
    local requests_dir="$project_dir/requests"
    local request_file="$requests_dir/$target_member.md"

    # Create requests directory if it doesn't exist
    mkdir -p "$requests_dir"

    # Add request with timestamp and requester
    local today=$(get_date)

    if [ ! -f "$request_file" ]; then
        echo "# Requests for $target_member" > "$request_file"
        echo "" >> "$request_file"
    fi

    echo "- [ ] [$today] **From $username:** $task" >> "$request_file"

    log_success "Request added for $target_member"

    # Auto-commit
    cd "$project_dir"
    log_info "Committing changes..."
    git add "$request_file"
    git commit -m "$username: Added request for $target_member" -m "$(cat <<'EOF'
ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"

    # Push if remote is configured
    if git remote get-url origin &>/dev/null; then
        log_info "Pushing to remote..."
        git push origin main 2>&1 || log_warning "Push failed - you may need to pull first or set up remote"
    else
        log_warning "No remote configured - commit saved locally"
    fi

    log_success "Request committed and pushed"
}

# Command: sync-requests (pull team requests into personal daily)
cmd_sync_requests() {
    local project="$1"

    if [ -z "$project" ]; then
        log_error "Please provide project name"
        echo "Usage: wip sync-requests <project-name>"
        exit 1
    fi

    local project_dir="$SHARED_DIR/$project"

    if [ ! -d "$project_dir" ]; then
        log_error "Shared project not found: $project_dir"
        exit 1
    fi

    # First sync the project to get latest requests
    log_info "Syncing project to get latest requests..."
    cmd_sync_project "$project"

    # Get user identity
    local me_file="$project_dir/.me"
    if [ ! -f "$me_file" ]; then
        log_error "Identity file not found. Please create $me_file with your name"
        exit 1
    fi

    local username=$(cat "$me_file")
    local request_file="$project_dir/requests/$username.md"

    if [ ! -f "$request_file" ]; then
        log_info "No requests found for you"
        return
    fi

    # Extract pending requests
    local pending_requests=$(grep "^- \[ \]" "$request_file" || echo "")

    if [ -z "$pending_requests" ]; then
        log_info "No pending requests found"
        return
    fi

    # Add to today's personal daily file
    local today=$(get_date)
    local personal_daily="$DAILY_DIR/$today.md"

    if [ ! -f "$personal_daily" ]; then
        log_error "Today's personal daily file doesn't exist. Run 'wip new-day' first."
        exit 1
    fi

    # Check if we've already added a Team Requests section
    if grep -q "### Team Requests - $project" "$personal_daily"; then
        log_warning "Team requests from $project already synced today"
        return
    fi

    # Add section with requests
    echo "" >> "$personal_daily"
    echo "### Team Requests - $project" >> "$personal_daily"
    echo "$pending_requests" >> "$personal_daily"

    local count=$(echo "$pending_requests" | wc -l | tr -d ' ')
    log_success "Added $count request(s) from $project to today's tasks"

    echo ""
    echo "Requests:"
    echo "$pending_requests"
}

# Command: sync-project
cmd_sync_project() {
    local project="$1"

    if [ -z "$project" ]; then
        log_error "Please provide a project name"
        echo "Usage: wip sync-project <project-name>"
        exit 1
    fi

    local project_dir="$SHARED_DIR/$project"

    if [ ! -d "$project_dir" ]; then
        log_error "Shared project not found: $project_dir"
        exit 1
    fi

    cd "$project_dir"

    # Check if remote is configured
    if ! git remote get-url origin &>/dev/null; then
        log_warning "No remote configured for this project"
        return
    fi

    log_info "Syncing project: $project"

    # Fetch
    git fetch origin 2>&1

    # Get current branch
    local current_branch=$(git rev-parse --abbrev-ref HEAD)

    # Check if behind remote
    local behind=$(git rev-list HEAD..origin/$current_branch --count 2>/dev/null || echo "0")

    if [ "$behind" -gt 0 ]; then
        log_info "You are $behind commit(s) behind. Pulling changes..."

        # Show what's new before pulling
        echo ""
        echo "New commits:"
        git log HEAD..origin/$current_branch --pretty=format:"%C(yellow)%h%C(reset) - %C(cyan)%an%C(reset): %s %C(green)(%ar)%C(reset)" 2>/dev/null
        echo ""
        echo ""

        # Pull
        if git pull origin $current_branch; then
            log_success "Successfully pulled changes"
        else
            log_error "Pull failed - you may have conflicts to resolve"
            exit 1
        fi
    else
        log_success "Project is up to date"
    fi

    # Check if ahead of remote
    local ahead=$(git rev-list origin/$current_branch..HEAD --count 2>/dev/null || echo "0")
    if [ "$ahead" -gt 0 ]; then
        log_warning "You have $ahead unpushed commit(s)"
    fi
}

# Command: team-status
cmd_team_status() {
    local project="$1"
    local days="${2:-3}"

    if [ -z "$project" ]; then
        log_error "Please provide a project name"
        echo "Usage: wip team-status <project-name> [days]"
        exit 1
    fi

    local project_dir="$SHARED_DIR/$project"

    if [ ! -d "$project_dir" ]; then
        log_error "Shared project not found: $project_dir"
        exit 1
    fi

    local daily_dir="$project_dir/daily"

    if [ ! -d "$daily_dir" ]; then
        log_warning "No daily logs found"
        return
    fi

    echo ""
    local project_name=$(get_project_name "$project_dir")
    echo "$project_name - Last $days days of activity:"
    echo ""

    # Get list of dates to check (last N days)
    for i in $(seq 0 $((days - 1))); do
        local check_date=$(date -d "$i days ago" +%Y-%m-%d 2>/dev/null || date -v-${i}d +%Y-%m-%d 2>/dev/null)
        local readable_date=$(get_readable_date "$check_date")

        # Determine relative date label
        if [ $i -eq 0 ]; then
            echo -e "${GREEN}$check_date (Today):${NC}"
        elif [ $i -eq 1 ]; then
            echo -e "${YELLOW}$check_date (Yesterday):${NC}"
        else
            echo "$check_date:"
        fi

        local found_any=false

        # Check each team member
        for member_dir in "$daily_dir"/*; do
            if [ -d "$member_dir" ]; then
                local member=$(basename "$member_dir")
                local member_file="$member_dir/$check_date.md"

                if [ -f "$member_file" ]; then
                    found_any=true
                    # Extract completed tasks
                    local completed=$(grep "^- \[x\]" "$member_file" | sed 's/^- \[x\] /  /' || echo "")
                    if [ -n "$completed" ]; then
                        echo -e "  ${BLUE}$member:${NC}"
                        echo "$completed"
                    else
                        # Show first few lines of notes if no completed tasks
                        local notes=$(sed -n '/## Notes/,/^$/p' "$member_file" | grep -v "^#" | grep -v "^$" | head -3 | sed 's/^/  /')
                        if [ -n "$notes" ]; then
                            echo -e "  ${BLUE}$member:${NC}"
                            echo "$notes"
                        fi
                    fi
                fi
            fi
        done

        if [ "$found_any" = false ]; then
            echo "  (No activity)"
        fi

        echo ""
    done
}

# Command: sync-all-shared
cmd_sync_all_shared() {
    if [ ! -d "$SHARED_DIR" ]; then
        log_warning "No shared projects directory found"
        return
    fi

    log_info "Syncing all shared projects..."
    echo ""

    local found_any=false
    local updated_count=0

    for project_dir in "$SHARED_DIR"/*; do
        if [ -d "$project_dir" ] && [ -d "$project_dir/.git" ]; then
            found_any=true
            local project=$(basename "$project_dir")

            cd "$project_dir"

            # Get project name from team.md if it exists
            local display_name=$(get_project_name "$project_dir")

            echo -e "${BLUE}$display_name${NC} (shared/$project)"

            # Check if remote is configured
            if ! git remote get-url origin &>/dev/null; then
                log_warning "  No remote configured"
                echo ""
                continue
            fi

            # Fetch
            git fetch origin 2>&1 | sed 's/^/  /'

            # Get current branch
            local current_branch=$(git rev-parse --abbrev-ref HEAD)

            # Check if behind remote
            local behind=$(git rev-list HEAD..origin/$current_branch --count 2>/dev/null || echo "0")

            if [ "$behind" -gt 0 ]; then
                echo -e "  ${YELLOW}Pulling $behind commit(s)...${NC}"

                # Show what's new
                git log HEAD..origin/$current_branch --pretty=format:"    %C(yellow)%h%C(reset) - %C(cyan)%an%C(reset): %s" 2>/dev/null
                echo ""

                # Pull
                if git pull origin $current_branch 2>&1 | sed 's/^/  /'; then
                    log_success "  Updated successfully"
                    updated_count=$((updated_count + 1))
                else
                    log_error "  Pull failed"
                fi
            else
                log_success "  Already up to date"
            fi

            # Check if ahead of remote
            local ahead=$(git rev-list origin/$current_branch..HEAD --count 2>/dev/null || echo "0")
            if [ "$ahead" -gt 0 ]; then
                log_warning "  You have $ahead unpushed commit(s)"
            fi

            echo ""
        fi
    done

    if [ "$found_any" = false ]; then
        log_warning "No shared projects found"
        echo ""
        echo "To create one:"
        echo "  wip clone-project <git-url> <project-name>"
    else
        echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
        if [ "$updated_count" -gt 0 ]; then
            log_success "Synced all projects - $updated_count updated"
        else
            log_success "All projects already up to date"
        fi
    fi
}

# Command: list-shared-projects
cmd_list_shared_projects() {
    if [ ! -d "$SHARED_DIR" ]; then
        log_warning "No shared projects directory found"
        return
    fi

    log_info "Shared projects:"
    echo ""

    local found_any=false
    for project_dir in "$SHARED_DIR"/*; do
        if [ -d "$project_dir" ] && [ -d "$project_dir/.git" ]; then
            found_any=true
            local project=$(basename "$project_dir")

            cd "$project_dir"

            # Get project name from team.md if it exists
            local display_name=$(get_project_name "$project_dir")

            # Check git status
            local status="synced"
            if git remote get-url origin &>/dev/null; then
                git fetch origin 2>/dev/null
                local current_branch=$(git rev-parse --abbrev-ref HEAD)
                local behind=$(git rev-list HEAD..origin/$current_branch --count 2>/dev/null || echo "0")
                local ahead=$(git rev-list origin/$current_branch..HEAD --count 2>/dev/null || echo "0")

                if [ "$behind" -gt 0 ]; then
                    status="${YELLOW}needs pull ($behind behind)${NC}"
                elif [ "$ahead" -gt 0 ]; then
                    status="${YELLOW}needs push ($ahead ahead)${NC}"
                else
                    status="${GREEN}synced${NC}"
                fi
            else
                status="${YELLOW}no remote${NC}"
            fi

            echo -e "  ${BLUE}$display_name${NC} ($project)"
            echo -e "    Status: $status"
            echo -e "    Location: shared/$project/"
            echo ""
        fi
    done

    if [ "$found_any" = false ]; then
        echo "  No shared projects found"
        echo ""
        echo "To create one:"
        echo "  wip clone-project <git-url> <project-name>"
    fi
}

# Command: clone-project
cmd_clone_project() {
    local git_url="$1"
    local project_name="$2"

    if [ -z "$git_url" ] || [ -z "$project_name" ]; then
        log_error "Please provide both git URL and project name"
        echo "Usage: wip clone-project <git-url> <project-name>"
        exit 1
    fi

    mkdir -p "$SHARED_DIR"

    local project_dir="$SHARED_DIR/$project_name"

    if [ -d "$project_dir" ]; then
        log_error "Project directory already exists: $project_dir"
        exit 1
    fi

    log_info "Cloning project..."
    if git clone "$git_url" "$project_dir"; then
        log_success "Project cloned to: $project_dir"

        cd "$project_dir"

        # Get user info from git config
        local git_name=$(git config user.name)
        local git_email=$(git config user.email)

        # Generate username from email (part before @) or name
        local suggested_username=""
        if [ -n "$git_email" ]; then
            suggested_username=$(echo "$git_email" | cut -d@ -f1 | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]')
        elif [ -n "$git_name" ]; then
            suggested_username=$(echo "$git_name" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]')
        fi

        # Ask for user identity with suggestion
        echo ""
        if [ -n "$suggested_username" ]; then
            echo "Detected from git config:"
            echo "  Name: $git_name"
            echo "  Email: $git_email"
            echo ""
            read -p "Username for this project [$suggested_username]: " username
            username=${username:-$suggested_username}
        else
            echo "What is your username for this project?"
            read -p "Username: " username
        fi

        echo "$username" > "$project_dir/.me"
        log_success "Identity saved: $username"

        # Check if user exists in team.md
        local team_file="$project_dir/team.md"
        local user_exists=false

        if [ -f "$team_file" ]; then
            if grep -q "^### .* (@$username)" "$team_file"; then
                user_exists=true
                log_success "Found your entry in team.md"
            fi
        fi

        # If user doesn't exist in team.md, offer to add them
        if [ "$user_exists" = false ] && [ -f "$team_file" ]; then
            echo ""
            log_warning "You're not in team.md yet. Would you like to add yourself?"
            read -p "Add to team.md? [Y/n]: " add_to_team
            add_to_team=${add_to_team:-Y}

            if [[ "$add_to_team" =~ ^[Yy] ]]; then
                # Get additional info
                read -p "Your full name [$git_name]: " full_name
                full_name=${full_name:-$git_name}

                read -p "Your role (e.g., Developer, Designer): " role
                role=${role:-Developer}

                read -p "Your email [$git_email]: " email
                email=${email:-$git_email}

                # Find the line with "<!-- Add additional team members as they join -->"
                local today=$(get_date)
                local new_member="### $full_name (@$username)
**Role:** $role
**Email:** $email
**Joined:** $today
**Notes:**

---

<!-- Add additional team members as they join -->"

                # Replace the comment line with the new member and restore the comment
                if grep -q "<!-- Add additional team members as they join -->" "$team_file"; then
                    # Use a temporary file for the replacement
                    awk -v member="$new_member" '
                    /<!-- Add additional team members as they join -->/ {
                        print member
                        next
                    }
                    { print }
                    ' "$team_file" > "$team_file.tmp" && mv "$team_file.tmp" "$team_file"

                    log_success "Added you to team.md"

                    # Commit the change
                    git add "$team_file"
                    if git diff --staged --quiet; then
                        log_info "No changes to commit"
                    else
                        git commit -m "Add $full_name (@$username) to team

Auto-registered via clone-project command.

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"

                        # Try to push
                        if git remote get-url origin &>/dev/null; then
                            log_info "Pushing to remote..."
                            if git push origin main 2>&1; then
                                log_success "Team roster updated on GitHub!"
                            else
                                log_warning "Push failed - you may need to pull first"
                                echo "Run: cd $project_dir && git pull && git push"
                            fi
                        fi
                    fi
                else
                    log_warning "Could not find team member insertion point in team.md"
                    echo "Please add yourself manually to team.md"
                fi
            fi
        fi

        # Create daily directory for this user
        mkdir -p "$project_dir/daily/$username"

        cd "$ROOT_DIR"

        # Add to projects/index.md
        local projects_index="$PROJECTS_DIR/index.md"
        if [ -f "$projects_index" ]; then
            echo "" >> "$projects_index"
            echo "## $project_name (embedded)" >> "$projects_index"
            echo "- **Status:** Active" >> "$projects_index"
            echo "- **Type:** Collaborative (embedded)" >> "$projects_index"
            echo "- **Review Cadence:** daily" >> "$projects_index"
            echo "- **Last Reviewed:** $(get_date)" >> "$projects_index"
            echo "- **Location:** \`shared/$project_name/\` (shared team git repository)" >> "$projects_index"
            echo "- **Remote:** $git_url" >> "$projects_index"
            echo "- **Next Steps:**" >> "$projects_index"
            echo "  - [ ] Review project structure and documentation" >> "$projects_index"
            echo "  - [ ] Make first contribution" >> "$projects_index"

            log_success "Added to projects index"
        fi

        echo ""
        log_info "Next steps:"
        echo "  1. Review the project: cd $project_dir"
        echo "  2. Log your work: wip log-project $project_name"
        echo "  3. Sync with team: wip sync-project $project_name"
    else
        log_error "Failed to clone project"
        exit 1
    fi
}

# Main command dispatcher
case "${1:-}" in
    new-day)
        cmd_new_day
        ;;
    add-task)
        cmd_add_task "$2"
        ;;
    review-yesterday)
        cmd_review_yesterday
        ;;
    review-projects)
        cmd_review_projects
        ;;
    weekly-summary)
        cmd_weekly_summary
        ;;
    monthly-summary)
        cmd_monthly_summary
        ;;
    list-days)
        cmd_list_days "$2"
        ;;
    open-project)
        cmd_open_project "$2"
        ;;
    log-project)
        cmd_log_project "$2"
        ;;
    team-log)
        cmd_team_log "$2" "$3"
        ;;
    add-request)
        cmd_add_request "$2" "$3" "$4"
        ;;
    sync-requests)
        cmd_sync_requests "$2"
        ;;
    sync-project)
        cmd_sync_project "$2"
        ;;
    sync-all-shared)
        cmd_sync_all_shared
        ;;
    team-status)
        cmd_team_status "$2" "$3"
        ;;
    list-shared-projects)
        cmd_list_shared_projects
        ;;
    list-embedded-projects)
        # Legacy alias for backwards compatibility
        cmd_list_shared_projects
        ;;
    clone-project)
        cmd_clone_project "$2" "$3"
        ;;
    *)
        echo "Formigio WIP - Work In Progress"
        echo ""
        echo "Usage: wip <command> [options]"
        echo ""
        echo "Personal Commands:"
        echo "  new-day                      Create today's daily file"
        echo "  add-task <task>              Add a task to today's list"
        echo "  review-yesterday             Review the previous working day"
        echo "  review-projects              Review projects due for review"
        echo "  weekly-summary               Create/open weekly summary"
        echo "  monthly-summary              Create/open monthly summary"
        echo "  list-days [n]                List last n daily files (default: 7)"
        echo "  open-project <name>          Open/create project notes"
        echo ""
        echo "Team Collaboration:"
        echo "  clone-project <url> <name>   Clone a shared project repo"
        echo "  log-project <name>           Log today's work (simple format)"
        echo "  team-log <name> <task>       Post structured work entry"
        echo "  sync-project <name>          Sync with team (pull updates)"
        echo "  sync-all-shared              Sync all shared projects at once"
        echo "  sync-requests <name>         Pull team requests into personal daily"
        echo "  add-request <proj> <mem> <t> Create todo for team member"
        echo "  team-status <name> [days]    Show recent team activity"
        echo "  list-shared-projects         List all shared projects"
        echo ""
        exit 1
        ;;
esac
